import numpy as np
import pandas as pd
from anndata import AnnData
from scipy.sparse import csr_matrix

import scvi
from scvi.model.base import BaseModelClass

from ._base import Cell2locationTrainSampleMixin, PltExportMixin
from ._cell2location_v1_module import Cell2locationModule


def intersect_var(adata, cell_state_df):
    """
    Subset adata and cell_state_df to common variables (rows in cell_state_df).

    Parameters
    ----------
    adata
        anndata object
    cell_state_df
        pd.DataFrame with variables (genes) in rows and cell types/factors/covariates in columns.

    Returns
    -------

    """
    intersect = np.intersect1d(cell_state_df.index, adata.var_names)
    return adata[:, intersect].copy(), cell_state_df.loc[intersect, :].copy()


def compute_cluster_averages(adata, labels, use_raw=True, layer=None):
    """
    Compute average expression of each gene in each cluster

    Parameters
    ----------
    adata
        AnnData object of reference single-cell dataset
    labels
        Name of adata.obs column containing cluster labels
    use_raw
        Use raw slow in adata?
    layer
        use layer in adata? provide layer name

    Returns
    -------
    pd.DataFrame of cluster average expression of each gene

    """

    if layer is not None:
        x = adata.layers["layer"]
        var_names = adata.var_names
    else:
        if not use_raw:
            x = adata.X
            var_names = adata.var_names
        else:
            if not adata.raw:
                raise ValueError(
                    "AnnData object has no raw data, change `use_raw=True, layer=None` or fix your object"
                )
            x = adata.raw.X
            var_names = adata.raw.var_names

    if sum(adata.obs.columns == labels) != 1:
        raise ValueError("cluster_col is absent in adata_ref.obs or not unique")

    all_clusters = np.unique(adata.obs[labels])
    averages_mat = np.zeros((1, x.shape[1]))

    for c in all_clusters:
        sparse_subset = csr_matrix(x[np.isin(adata.obs[labels], c), :])
        aver = sparse_subset.mean(0)
        averages_mat = np.concatenate((averages_mat, aver))
    averages_mat = averages_mat[1:, :].T
    averages_df = pd.DataFrame(data=averages_mat, index=var_names, columns=all_clusters)

    return averages_df


class Cell2locationPltExportMixin:
    def sample2df(
        self,
        samples: dict,
        site_name: str = "w_sf",
        name_prefix: str = "cell_abundance_",
    ):
        """Export spatial cell abundance as Pandas data frames
        (means, 5%/95% quantiles and sd of posterior distribution).

        Parameters
        ----------
        samples
            dictionary with posterior mean, 5%/95% quantiles, SD, samples, generated by `.sample_posterior()`
        site_name
            name of the model parameter to be exported

        Returns
        -------
        list with 4 Pandas data frames corresponding to means, 5%/95% quantiles and sd of posterior distribution

        """

        results = dict()

        results["mean_" + name_prefix + site_name] = pd.DataFrame.from_records(
            samples["post_sample_means"][site_name],
            index=self.adata.obs_names,
            columns=["mean_" + name_prefix + site_name + i for i in self.factor_names_],
        )

        results["sd_" + name_prefix + site_name] = pd.DataFrame.from_records(
            samples["post_sample_sds"][site_name],
            index=self.adata.obs_names,
            columns=["sd_" + name_prefix + site_name + i for i in self.factor_names_],
        )

        results["q05_" + name_prefix + site_name] = pd.DataFrame.from_records(
            samples["post_sample_q05"][site_name],
            index=self.adata.obs_names,
            columns=["q05_" + name_prefix + site_name + i for i in self.factor_names_],
        )

        results["q95_" + name_prefix + site_name] = pd.DataFrame.from_records(
            samples["post_sample_q95"][site_name],
            index=self.adata.obs_names,
            columns=["q95_" + name_prefix + site_name + i for i in self.factor_names_],
        )

        return results


class Cell2location(
    Cell2locationTrainSampleMixin,
    BaseModelClass,
    PltExportMixin,
    Cell2locationPltExportMixin,
):
    """
    Reimplementation of cell2location [Kleshchevnikov20]_ model. User-end model class.

    https://github.com/BayraktarLab/cell2location

    Parameters
    ----------
    sc_adata
        single-cell AnnData object that has been registered via :func:`~scvi.data.setup_anndata`.
    use_gpu
        Use the GPU?
    **model_kwargs
        Keyword args for :class:`~scvi.external.LocationModelLinearDependentWMultiExperimentModel`

    Examples
    --------
    TODO add example
    >>>
    """

    def __init__(
        self,
        adata: AnnData,
        cell_state_df: pd.DataFrame,
        batch_size=None,
        module=None,
        **model_kwargs,
    ):
        # add index for each cell (provided to pyro plate for correct minibatching)
        adata.obs["_indices"] = np.arange(adata.n_obs).astype("int64")
        scvi.data.register_tensor_from_anndata(
            adata,
            registry_key="ind_x",
            adata_attr_name="obs",
            adata_key_name="_indices",
        )

        super().__init__(adata)

        if module is None:
            module = Cell2locationModule

        self.cell_state_df_ = cell_state_df
        self.n_factors_ = cell_state_df.shape[1]
        self.factor_names_ = cell_state_df.columns.values

        self.module = module(
            n_obs=self.summary_stats["n_cells"],
            n_vars=self.summary_stats["n_vars"],
            n_factors=self.n_factors_,
            n_batch=self.summary_stats["n_batch"],
            batch_size=batch_size,
            cell_state_mat=self.cell_state_df_.values.astype("float32"),
            **model_kwargs,
        )
        self._model_summary_string = f'scVI-cell2location Model with the following params: \nn_factors: {self.n_factors_} \nn_batch: {self.summary_stats["n_batch"]} '
        self.init_params_ = self._get_init_params(locals())
